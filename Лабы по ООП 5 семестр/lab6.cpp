//	1. Создать базовый класс Base, в котором описать в разделе
// public поле i типа int, в разделе protected поле l типа long, в
// разделе private поле d типа double.Написать конструктор,
// инициализирующий поля i, l и d тремя задаваемыми значениями.
// 
//	2. Создать класс Derived, производный от класса Base
// (наследование типа public), в котором в разделе private
// описано поле f типа float.В классе Derived создать конструктор
// без параметров и конструктор с четырьмя параметрами для
// инициализации всех полей объекта.
// 
//	3. В функции main описать неинициализированный объект
// класса Derived и откомпилировать программу.Если есть
// проблемы, то устранить их. Вывести размеры типов Base и Derived
// и объяснить результаты.
// 
//	4. Описать инициализированный объект класса Derived.
// Продемонстрировать, инициализацию каких полей,
// унаследованных от класса Base, можно выполнять с помощью
// присваивания непосредственно в конструкторе класса Derived.
// Для исследования можно вносить необходимые изменения в
// конструкторы классов Base и Derived.
// 
//	5. Перегрузить операцию вставки в поток для объектов
// класса Derived таким образом, чтобы выводились адреса и
// значения всех полей объекта. К каким полям, унаследованным от
// класса Base, нет доступа ? Для снятия проблемы добавить в классе
// Base необходимые интерфейсные функции. Создав объект класса
// Derived, исследовать размещение полей в памяти.В отчете
// привести схематическую структуру объекта.
// 
//	6. Описать класс Derived1, производный(public) от класса
// Derived и не имеющий новых полей.В классе описать конструктор
// со всеми необходимыми параметрами(сколько их нужно ? ).Класс
// имеет общедоступную функцию void foo(), которая модифицирует
// значения полей, унаследованных от базового класса(i++; l += 1;).
// Откомпилировать программу.Заменить тип наследования Derived
// от Base на private и вновь откомпилировать программу.Какая
// возникла проблема ? Для ее решения использовать возможность
// восстановления уровня доступа к компонентам базового класса.
// 
//	7. Вернуть для Derived тип наследования public.На
// глобальном уровне и в классах Base и Derived описать функции
// void ff(), которые сообщают о своей принадлежности к классу или
// глобальному уровню.В функции foo класса Derived1 добавить
// вызовы всех трех функций ff.В каких разделах классов Base и
// Derived нужно описать функции ff, чтобы они были доступны в
// Derived1 ? Проверить работу программы, вызвав функцию foo для
// какого - либо объекта класса Derived1.
// 
//	8. Оставить в функции Derived::foo только один вызов в
// виде ff(); и проверить работу программы в следующих вариантах.
// Вначале функция ff определена в классах Derived, Base и на
// глобальном уровне.Затем ее описание убираем вначале из класса
// Derived, а затем из классов Derived и Base.Как в каждом случае
// это отражается на работе программы ?
// 
//	9. Класс Base1, имеет одно закрытое поле i целого типа.
// Первый конструктор не имеет параметров и обнуляет i.Второй
// имеет один параметр типа int, используемый для инициализации i
// произвольными значениями.Класс имеет две общедоступные
// интерфейсные функции void put(int) и int get(void), которые
// позволяют изменить или прочесть значение i.Класс Base2, имеет
// одно закрытое поле - массив name из 20 элементов.Первый
// конструктор не имеет параметров и инициализирует поле name
// словом "Пусто".Второй имеет один параметр типа char*,
// используемый для инициализации name значениями символьных
// строк.Класс имеет две общедоступные интерфейсные функции
// void put(char*) и char* get(void), которые позволяют изменить или
// прочесть значение name.Класс Derived имеет одно закрытое поле
// ch типа char.Первый конструктор не имеет параметров и
// присваивает ch значение 'V' (от void - пустой).Второй конструктор
// имеет три параметра типов char, char* и int, используемые для
// инициализации соответственно полей ch, name и i.Класс имеет
// две общедоступные интерфейсные функции void put(char) и char
// get(void), которые позволяют изменить или прочесть значение ch.
// Кроме того, в нем объявляется как дружественная операция
// вставки в поток вывода, которая выводит на экран значения i,
// name и ch.
//	а).В функции main описать переменную типа Derived без
// инициализации и вывести ее значение с помощью перегруженной
// операции вставки в поток.Выяснить порядок вызова
// конструкторов.
//	б).Описать другую переменную класса Derived,
// инициализировав ее явно некоторыми значениями.Вывести
// значение этой переменной на экран и проанализировать порядок
// вызова конструкторов.
//	в).В конструкторе класса Derived с параметрами изменить
// порядок вызова конструкторов базовых классов.Проверить, как
// это отразилось на работе программы и почему.
//	г).Изменить порядок наследования базовых классов в
// описании класса Derived и проверить, как это отразилось на
// работе программы.
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <locale>

//
// Задание 1
//
class Base {
	double d;
protected:
	long l;
public:
	int i;
	Base(int i, long l, double d) : i(i), l(l), d(d) {};

	double& getRawD() {
		return d;
	}

	void ff() {
		std::cout << "я база\n";
	}
};

//
// Задание 2-5
//
class Derived : public Base {
	friend std::ostream& operator<<(std::ostream&, Derived&);
	float f;
public:
	Derived(int i, long l, double d, float f) : Base(i, l, d), f(f) {};
	Derived() : Derived(0, 0, 0, 0) {
	};

	void ff() {
		std::cout << "я шестерка базы\n";
	}
};

//
// Задание 9
//
class Base2; 
class Derived2;

class Base1 {
	friend std::ostream& operator<<(std::ostream&, Derived2&);
	friend class Base2;
	friend class Derived2;
	int i;
public:
	Base1() : i(0) {}
	Base1(int i) : i(i) {}

	void put(int nv) {
		i = nv;
	}

	int get() {
		return i;
	}
};

class Base2 : public Base1 {
	friend std::ostream& operator<<(std::ostream&, Derived2&);
	char name[20];
	friend class Derived2;
public:
	Base2(const char* input) {
		strcpy(name, input);
	}

	Base2() : Base2("Привет") {}

	void put(char* contents) {
		strcpy(name, contents);
	}

	const char* get() {
		return name;
	}
};

class Derived2 : public Base2 {
	friend std::ostream& operator<<(std::ostream&, Derived2&);
	char ch;
public:
	Derived2(const char ch, int i, const char* name) {
		strcpy(this->name, name);
		this->ch = ch;
		this->i = i;
	}
	Derived2(const char ch) : ch(ch) {}
	Derived2() : ch('V') {}

	void put(char contents) {
		ch = contents;
	}

	const char get() {
		return ch;
	}
};

std::ostream& operator<<(std::ostream& os, Derived2& der)
{
	os
		<< "Derived2.i = " << der.i << "\n"
		<< "Derived2.name = " << der.name << "\n"
		<< "Derived2.ch = " << der.ch << "\n";

	return os;
}

std::ostream& operator<<(std::ostream& os, Derived& der)
{
	os
		<< "Derived.d = " << der.getRawD() << " (" << &(der.getRawD()) << ")\n"
		<< "Derived.l = " << der.f << " (" << &(der.f) << ")\n"
		<< "Derived.i = " << der.i << " (" << &(der.i) << ")\n"
		<< "Derived.f = " << der.l << " (" << &(der.l) << ")\n";

	return os;
}

//
// Задание 6
//
class Derived1 : public Derived {
public:
	Derived1(int i, long l, double d, float f) : Derived(i, l, d, f) {}
	Derived1() : Derived() {}
	void foo() {
		i++;
		l += 1;

		ff();
	}
};

void ff() {
	std::cout << "я глобальная элита\n";
}

void testStart() {

	Derived der;
	std::cout << sizeof(Base) << ' ' << sizeof(Derived) << '\n';
	std::cout << der;

	//der.foo();
}

void testLame() {
	Derived der;
	Derived der1(1, 1, 1, 1);
	std::cout << der;
	std::cout << der;
}

int main()
{
	setlocale(0, "Russian");
	testStart();
}